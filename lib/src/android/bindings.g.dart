// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.io.ByteArrayOutputStream`
class ByteArrayOutputStream extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<ByteArrayOutputStream> $type;

  @jni$_.internal
  ByteArrayOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ByteArrayOutputStream');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ByteArrayOutputStream?> nullableType =
      $ByteArrayOutputStream$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<ByteArrayOutputStream> type =
      $ByteArrayOutputStream$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayOutputStream() {
    return ByteArrayOutputStream.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayOutputStream.new$1(int i) {
    return ByteArrayOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toByteArray = _class.instanceMethodId(
    r'toByteArray',
    r'()[B',
  );

  static final _toByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] toByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? toByteArray() {
    return _toByteArray(
      reference.pointer,
      _id_toByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toString$2 = _class.instanceMethodId(
    r'toString',
    r'(I)Ljava/lang/String;',
  );

  static final _toString$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String toString(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$2(int i) {
    return _toString$2(
      reference.pointer,
      _id_toString$2 as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toString$3 = _class.instanceMethodId(
    r'toString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _toString$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String toString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toString$3(
      reference.pointer,
      _id_toString$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toString$4 = _class.instanceMethodId(
    r'toString',
    r'(Ljava/nio/charset/Charset;)Ljava/lang/String;',
  );

  static final _toString$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String toString(java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$4(jni$_.JObject? charset) {
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _toString$4(
      reference.pointer,
      _id_toString$4 as jni$_.JMethodIDPtr,
      _$charset.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_write = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write(
      reference.pointer,
      _id_write as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'(I)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write$1(int i) {
    _write$1(reference.pointer, _id_write$1 as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'([B)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(byte[] bs)`
  void writeBytes(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _writeTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeTo(java.io.OutputStream outputStream)`
  void writeTo(jni$_.JObject? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    _writeTo(
      reference.pointer,
      _id_writeTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).check();
  }
}

final class $ByteArrayOutputStream$NullableType$
    extends jni$_.JType<ByteArrayOutputStream?> {
  @jni$_.internal
  const $ByteArrayOutputStream$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayOutputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ByteArrayOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ByteArrayOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ByteArrayOutputStream$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteArrayOutputStream$NullableType$) &&
        other is $ByteArrayOutputStream$NullableType$;
  }
}

final class $ByteArrayOutputStream$Type$
    extends jni$_.JType<ByteArrayOutputStream> {
  @jni$_.internal
  const $ByteArrayOutputStream$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayOutputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayOutputStream fromReference(jni$_.JReference reference) =>
      ByteArrayOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<ByteArrayOutputStream?> get nullableType =>
      const $ByteArrayOutputStream$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ByteArrayOutputStream$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteArrayOutputStream$Type$) &&
        other is $ByteArrayOutputStream$Type$;
  }
}

/// from: `android.graphics.BitmapFactory$Options`
class BitmapFactory$Options extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<BitmapFactory$Options> $type;

  @jni$_.internal
  BitmapFactory$Options.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/BitmapFactory$Options',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory$Options?> nullableType =
      $BitmapFactory$Options$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory$Options> type =
      $BitmapFactory$Options$Type$();
  static final _id_inBitmap = _class.instanceFieldId(
    r'inBitmap',
    r'Landroid/graphics/Bitmap;',
  );

  /// from: `public android.graphics.Bitmap inBitmap`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? get inBitmap => _id_inBitmap.get(this, const $Bitmap$NullableType$());

  /// from: `public android.graphics.Bitmap inBitmap`
  /// The returned object must be released after use, by calling the [release] method.
  set inBitmap(Bitmap? value) =>
      _id_inBitmap.set(this, const $Bitmap$NullableType$(), value);

  static final _id_inDensity = _class.instanceFieldId(r'inDensity', r'I');

  /// from: `public int inDensity`
  int get inDensity => _id_inDensity.get(this, const jni$_.jintType());

  /// from: `public int inDensity`
  set inDensity(int value) =>
      _id_inDensity.set(this, const jni$_.jintType(), value);

  static final _id_inDither = _class.instanceFieldId(r'inDither', r'Z');

  /// from: `public boolean inDither`
  bool get inDither => _id_inDither.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inDither`
  set inDither(bool value) =>
      _id_inDither.set(this, const jni$_.jbooleanType(), value);

  static final _id_inInputShareable = _class.instanceFieldId(
    r'inInputShareable',
    r'Z',
  );

  /// from: `public boolean inInputShareable`
  bool get inInputShareable =>
      _id_inInputShareable.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inInputShareable`
  set inInputShareable(bool value) =>
      _id_inInputShareable.set(this, const jni$_.jbooleanType(), value);

  static final _id_inJustDecodeBounds = _class.instanceFieldId(
    r'inJustDecodeBounds',
    r'Z',
  );

  /// from: `public boolean inJustDecodeBounds`
  bool get inJustDecodeBounds =>
      _id_inJustDecodeBounds.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inJustDecodeBounds`
  set inJustDecodeBounds(bool value) =>
      _id_inJustDecodeBounds.set(this, const jni$_.jbooleanType(), value);

  static final _id_inMutable = _class.instanceFieldId(r'inMutable', r'Z');

  /// from: `public boolean inMutable`
  bool get inMutable => _id_inMutable.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inMutable`
  set inMutable(bool value) =>
      _id_inMutable.set(this, const jni$_.jbooleanType(), value);

  static final _id_inPreferQualityOverSpeed = _class.instanceFieldId(
    r'inPreferQualityOverSpeed',
    r'Z',
  );

  /// from: `public boolean inPreferQualityOverSpeed`
  bool get inPreferQualityOverSpeed =>
      _id_inPreferQualityOverSpeed.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inPreferQualityOverSpeed`
  set inPreferQualityOverSpeed(bool value) =>
      _id_inPreferQualityOverSpeed.set(this, const jni$_.jbooleanType(), value);

  static final _id_inPreferredColorSpace = _class.instanceFieldId(
    r'inPreferredColorSpace',
    r'Landroid/graphics/ColorSpace;',
  );

  /// from: `public android.graphics.ColorSpace inPreferredColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get inPreferredColorSpace =>
      _id_inPreferredColorSpace.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.ColorSpace inPreferredColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredColorSpace(jni$_.JObject? value) => _id_inPreferredColorSpace
      .set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_inPreferredConfig = _class.instanceFieldId(
    r'inPreferredConfig',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `public android.graphics.Bitmap$Config inPreferredConfig`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap$Config? get inPreferredConfig =>
      _id_inPreferredConfig.get(this, const $Bitmap$Config$NullableType$());

  /// from: `public android.graphics.Bitmap$Config inPreferredConfig`
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredConfig(Bitmap$Config? value) => _id_inPreferredConfig.set(
    this,
    const $Bitmap$Config$NullableType$(),
    value,
  );

  static final _id_inPremultiplied = _class.instanceFieldId(
    r'inPremultiplied',
    r'Z',
  );

  /// from: `public boolean inPremultiplied`
  bool get inPremultiplied =>
      _id_inPremultiplied.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inPremultiplied`
  set inPremultiplied(bool value) =>
      _id_inPremultiplied.set(this, const jni$_.jbooleanType(), value);

  static final _id_inPurgeable = _class.instanceFieldId(r'inPurgeable', r'Z');

  /// from: `public boolean inPurgeable`
  bool get inPurgeable => _id_inPurgeable.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inPurgeable`
  set inPurgeable(bool value) =>
      _id_inPurgeable.set(this, const jni$_.jbooleanType(), value);

  static final _id_inSampleSize = _class.instanceFieldId(r'inSampleSize', r'I');

  /// from: `public int inSampleSize`
  int get inSampleSize => _id_inSampleSize.get(this, const jni$_.jintType());

  /// from: `public int inSampleSize`
  set inSampleSize(int value) =>
      _id_inSampleSize.set(this, const jni$_.jintType(), value);

  static final _id_inScaled = _class.instanceFieldId(r'inScaled', r'Z');

  /// from: `public boolean inScaled`
  bool get inScaled => _id_inScaled.get(this, const jni$_.jbooleanType());

  /// from: `public boolean inScaled`
  set inScaled(bool value) =>
      _id_inScaled.set(this, const jni$_.jbooleanType(), value);

  static final _id_inScreenDensity = _class.instanceFieldId(
    r'inScreenDensity',
    r'I',
  );

  /// from: `public int inScreenDensity`
  int get inScreenDensity =>
      _id_inScreenDensity.get(this, const jni$_.jintType());

  /// from: `public int inScreenDensity`
  set inScreenDensity(int value) =>
      _id_inScreenDensity.set(this, const jni$_.jintType(), value);

  static final _id_inTargetDensity = _class.instanceFieldId(
    r'inTargetDensity',
    r'I',
  );

  /// from: `public int inTargetDensity`
  int get inTargetDensity =>
      _id_inTargetDensity.get(this, const jni$_.jintType());

  /// from: `public int inTargetDensity`
  set inTargetDensity(int value) =>
      _id_inTargetDensity.set(this, const jni$_.jintType(), value);

  static final _id_inTempStorage = _class.instanceFieldId(
    r'inTempStorage',
    r'[B',
  );

  /// from: `public byte[] inTempStorage`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? get inTempStorage =>
      _id_inTempStorage.get(this, const jni$_.$JByteArray$NullableType$());

  /// from: `public byte[] inTempStorage`
  /// The returned object must be released after use, by calling the [release] method.
  set inTempStorage(jni$_.JByteArray? value) => _id_inTempStorage.set(
    this,
    const jni$_.$JByteArray$NullableType$(),
    value,
  );

  static final _id_mCancel = _class.instanceFieldId(r'mCancel', r'Z');

  /// from: `public boolean mCancel`
  bool get mCancel => _id_mCancel.get(this, const jni$_.jbooleanType());

  /// from: `public boolean mCancel`
  set mCancel(bool value) =>
      _id_mCancel.set(this, const jni$_.jbooleanType(), value);

  static final _id_outColorSpace = _class.instanceFieldId(
    r'outColorSpace',
    r'Landroid/graphics/ColorSpace;',
  );

  /// from: `public android.graphics.ColorSpace outColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get outColorSpace =>
      _id_outColorSpace.get(this, const jni$_.$JObject$NullableType$());

  /// from: `public android.graphics.ColorSpace outColorSpace`
  /// The returned object must be released after use, by calling the [release] method.
  set outColorSpace(jni$_.JObject? value) =>
      _id_outColorSpace.set(this, const jni$_.$JObject$NullableType$(), value);

  static final _id_outConfig = _class.instanceFieldId(
    r'outConfig',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `public android.graphics.Bitmap$Config outConfig`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap$Config? get outConfig =>
      _id_outConfig.get(this, const $Bitmap$Config$NullableType$());

  /// from: `public android.graphics.Bitmap$Config outConfig`
  /// The returned object must be released after use, by calling the [release] method.
  set outConfig(Bitmap$Config? value) =>
      _id_outConfig.set(this, const $Bitmap$Config$NullableType$(), value);

  static final _id_outHeight = _class.instanceFieldId(r'outHeight', r'I');

  /// from: `public int outHeight`
  int get outHeight => _id_outHeight.get(this, const jni$_.jintType());

  /// from: `public int outHeight`
  set outHeight(int value) =>
      _id_outHeight.set(this, const jni$_.jintType(), value);

  static final _id_outMimeType = _class.instanceFieldId(
    r'outMimeType',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String outMimeType`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get outMimeType =>
      _id_outMimeType.get(this, const jni$_.$JString$NullableType$());

  /// from: `public java.lang.String outMimeType`
  /// The returned object must be released after use, by calling the [release] method.
  set outMimeType(jni$_.JString? value) =>
      _id_outMimeType.set(this, const jni$_.$JString$NullableType$(), value);

  static final _id_outWidth = _class.instanceFieldId(r'outWidth', r'I');

  /// from: `public int outWidth`
  int get outWidth => _id_outWidth.get(this, const jni$_.jintType());

  /// from: `public int outWidth`
  set outWidth(int value) =>
      _id_outWidth.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory$Options() {
    return BitmapFactory$Options.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_requestCancelDecode = _class.instanceMethodId(
    r'requestCancelDecode',
    r'()V',
  );

  static final _requestCancelDecode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void requestCancelDecode()`
  void requestCancelDecode() {
    _requestCancelDecode(
      reference.pointer,
      _id_requestCancelDecode as jni$_.JMethodIDPtr,
    ).check();
  }
}

final class $BitmapFactory$Options$NullableType$
    extends jni$_.JType<BitmapFactory$Options?> {
  @jni$_.internal
  const $BitmapFactory$Options$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory$Options;';

  @jni$_.internal
  @core$_.override
  BitmapFactory$Options? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BitmapFactory$Options.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory$Options?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$Options$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$Options$NullableType$) &&
        other is $BitmapFactory$Options$NullableType$;
  }
}

final class $BitmapFactory$Options$Type$
    extends jni$_.JType<BitmapFactory$Options> {
  @jni$_.internal
  const $BitmapFactory$Options$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory$Options;';

  @jni$_.internal
  @core$_.override
  BitmapFactory$Options fromReference(jni$_.JReference reference) =>
      BitmapFactory$Options.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory$Options?> get nullableType =>
      const $BitmapFactory$Options$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$Options$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$Options$Type$) &&
        other is $BitmapFactory$Options$Type$;
  }
}

/// from: `android.graphics.BitmapFactory`
class BitmapFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<BitmapFactory> $type;

  @jni$_.internal
  BitmapFactory.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/BitmapFactory');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory?> nullableType =
      $BitmapFactory$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BitmapFactory> type = $BitmapFactory$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory() {
    return BitmapFactory.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_decodeByteArray = _class.staticMethodId(
    r'decodeByteArray',
    r'([BII)Landroid/graphics/Bitmap;',
  );

  static final _decodeByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeByteArray(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _decodeByteArray(
      _class.reference.pointer,
      _id_decodeByteArray as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeByteArray$1 = _class.staticMethodId(
    r'decodeByteArray',
    r'([BIILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeByteArray$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeByteArray$1(
    jni$_.JByteArray? bs,
    int i,
    int i1,
    BitmapFactory$Options? options,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeByteArray$1(
      _class.reference.pointer,
      _id_decodeByteArray$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
      _$options.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeFile = _class.staticMethodId(
    r'decodeFile',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFile(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeFile(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _decodeFile(
      _class.reference.pointer,
      _id_decodeFile as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeFile$1 = _class.staticMethodId(
    r'decodeFile',
    r'(Ljava/lang/String;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFile$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFile(java.lang.String string, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeFile$1(
    jni$_.JString? string,
    BitmapFactory$Options? options,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeFile$1(
      _class.reference.pointer,
      _id_decodeFile$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$options.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeFileDescriptor = _class.staticMethodId(
    r'decodeFileDescriptor',
    r'(Ljava/io/FileDescriptor;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFileDescriptor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeFileDescriptor(jni$_.JObject? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return _decodeFileDescriptor(
      _class.reference.pointer,
      _id_decodeFileDescriptor as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeFileDescriptor$1 = _class.staticMethodId(
    r'decodeFileDescriptor',
    r'(Ljava/io/FileDescriptor;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeFileDescriptor$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeFileDescriptor$1(
    jni$_.JObject? fileDescriptor,
    jni$_.JObject? rect,
    BitmapFactory$Options? options,
  ) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeFileDescriptor$1(
      _class.reference.pointer,
      _id_decodeFileDescriptor$1 as jni$_.JMethodIDPtr,
      _$fileDescriptor.pointer,
      _$rect.pointer,
      _$options.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeResource = _class.staticMethodId(
    r'decodeResource',
    r'(Landroid/content/res/Resources;I)Landroid/graphics/Bitmap;',
  );

  static final _decodeResource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeResource(jni$_.JObject? resources, int i) {
    final _$resources = resources?.reference ?? jni$_.jNullReference;
    return _decodeResource(
      _class.reference.pointer,
      _id_decodeResource as jni$_.JMethodIDPtr,
      _$resources.pointer,
      i,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeResource$1 = _class.staticMethodId(
    r'decodeResource',
    r'(Landroid/content/res/Resources;ILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeResource$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeResource$1(
    jni$_.JObject? resources,
    int i,
    BitmapFactory$Options? options,
  ) {
    final _$resources = resources?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeResource$1(
      _class.reference.pointer,
      _id_decodeResource$1 as jni$_.JMethodIDPtr,
      _$resources.pointer,
      i,
      _$options.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeResourceStream = _class.staticMethodId(
    r'decodeResourceStream',
    r'(Landroid/content/res/Resources;Landroid/util/TypedValue;Ljava/io/InputStream;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeResourceStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeResourceStream(android.content.res.Resources resources, android.util.TypedValue typedValue, java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeResourceStream(
    jni$_.JObject? resources,
    jni$_.JObject? typedValue,
    jni$_.JObject? inputStream,
    jni$_.JObject? rect,
    BitmapFactory$Options? options,
  ) {
    final _$resources = resources?.reference ?? jni$_.jNullReference;
    final _$typedValue = typedValue?.reference ?? jni$_.jNullReference;
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeResourceStream(
      _class.reference.pointer,
      _id_decodeResourceStream as jni$_.JMethodIDPtr,
      _$resources.pointer,
      _$typedValue.pointer,
      _$inputStream.pointer,
      _$rect.pointer,
      _$options.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeStream = _class.staticMethodId(
    r'decodeStream',
    r'(Ljava/io/InputStream;)Landroid/graphics/Bitmap;',
  );

  static final _decodeStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeStream(jni$_.JObject? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return _decodeStream(
      _class.reference.pointer,
      _id_decodeStream as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_decodeStream$1 = _class.staticMethodId(
    r'decodeStream',
    r'(Ljava/io/InputStream;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _decodeStream$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? decodeStream$1(
    jni$_.JObject? inputStream,
    jni$_.JObject? rect,
    BitmapFactory$Options? options,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _decodeStream$1(
      _class.reference.pointer,
      _id_decodeStream$1 as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
      _$rect.pointer,
      _$options.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }
}

final class $BitmapFactory$NullableType$ extends jni$_.JType<BitmapFactory?> {
  @jni$_.internal
  const $BitmapFactory$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory;';

  @jni$_.internal
  @core$_.override
  BitmapFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BitmapFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$NullableType$) &&
        other is $BitmapFactory$NullableType$;
  }
}

final class $BitmapFactory$Type$ extends jni$_.JType<BitmapFactory> {
  @jni$_.internal
  const $BitmapFactory$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/BitmapFactory;';

  @jni$_.internal
  @core$_.override
  BitmapFactory fromReference(jni$_.JReference reference) =>
      BitmapFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<BitmapFactory?> get nullableType =>
      const $BitmapFactory$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BitmapFactory$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory$Type$) &&
        other is $BitmapFactory$Type$;
  }
}

/// from: `android.graphics.Bitmap$CompressFormat`
class Bitmap$CompressFormat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Bitmap$CompressFormat> $type;

  @jni$_.internal
  Bitmap$CompressFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/Bitmap$CompressFormat',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Bitmap$CompressFormat?> nullableType =
      $Bitmap$CompressFormat$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Bitmap$CompressFormat> type =
      $Bitmap$CompressFormat$Type$();
  static final _id_JPEG = _class.staticFieldId(
    r'JPEG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat JPEG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get JPEG =>
      _id_JPEG.get(_class, const $Bitmap$CompressFormat$Type$());

  static final _id_PNG = _class.staticFieldId(
    r'PNG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat PNG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get PNG =>
      _id_PNG.get(_class, const $Bitmap$CompressFormat$Type$());

  static final _id_WEBP = _class.staticFieldId(
    r'WEBP',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP =>
      _id_WEBP.get(_class, const $Bitmap$CompressFormat$Type$());

  static final _id_WEBP_LOSSLESS = _class.staticFieldId(
    r'WEBP_LOSSLESS',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSLESS =>
      _id_WEBP_LOSSLESS.get(_class, const $Bitmap$CompressFormat$Type$());

  static final _id_WEBP_LOSSY = _class.staticFieldId(
    r'WEBP_LOSSY',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSY =>
      _id_WEBP_LOSSY.get(_class, const $Bitmap$CompressFormat$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public android.graphics.Bitmap$CompressFormat[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$CompressFormat?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Bitmap$CompressFormat?>?>(
      const jni$_.$JArray$NullableType$<Bitmap$CompressFormat?>(
        $Bitmap$CompressFormat$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Bitmap$CompressFormat?>(
      const $Bitmap$CompressFormat$NullableType$(),
    );
  }
}

final class $Bitmap$CompressFormat$NullableType$
    extends jni$_.JType<Bitmap$CompressFormat?> {
  @jni$_.internal
  const $Bitmap$CompressFormat$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Bitmap$CompressFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Bitmap$CompressFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$NullableType$) &&
        other is $Bitmap$CompressFormat$NullableType$;
  }
}

final class $Bitmap$CompressFormat$Type$
    extends jni$_.JType<Bitmap$CompressFormat> {
  @jni$_.internal
  const $Bitmap$CompressFormat$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat fromReference(jni$_.JReference reference) =>
      Bitmap$CompressFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Bitmap$CompressFormat?> get nullableType =>
      const $Bitmap$CompressFormat$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$Type$) &&
        other is $Bitmap$CompressFormat$Type$;
  }
}

/// from: `android.graphics.Bitmap$Config`
class Bitmap$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Bitmap$Config> $type;

  @jni$_.internal
  Bitmap$Config.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap$Config');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Bitmap$Config?> nullableType =
      $Bitmap$Config$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Bitmap$Config> type = $Bitmap$Config$Type$();
  static final _id_ALPHA_8 = _class.staticFieldId(
    r'ALPHA_8',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ALPHA_8`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ALPHA_8 =>
      _id_ALPHA_8.get(_class, const $Bitmap$Config$Type$());

  static final _id_ARGB_4444 = _class.staticFieldId(
    r'ARGB_4444',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_4444`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_4444 =>
      _id_ARGB_4444.get(_class, const $Bitmap$Config$Type$());

  static final _id_ARGB_8888 = _class.staticFieldId(
    r'ARGB_8888',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_8888`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_8888 =>
      _id_ARGB_8888.get(_class, const $Bitmap$Config$Type$());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get HARDWARE =>
      _id_HARDWARE.get(_class, const $Bitmap$Config$Type$());

  static final _id_RGBA_1010102 = _class.staticFieldId(
    r'RGBA_1010102',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_1010102`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_1010102 =>
      _id_RGBA_1010102.get(_class, const $Bitmap$Config$Type$());

  static final _id_RGBA_F16 = _class.staticFieldId(
    r'RGBA_F16',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_F16`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_F16 =>
      _id_RGBA_F16.get(_class, const $Bitmap$Config$Type$());

  static final _id_RGB_565 = _class.staticFieldId(
    r'RGB_565',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGB_565`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGB_565 =>
      _id_RGB_565.get(_class, const $Bitmap$Config$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$Config;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public android.graphics.Bitmap$Config[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$Config?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Bitmap$Config?>?>(
      const jni$_.$JArray$NullableType$<Bitmap$Config?>(
        $Bitmap$Config$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap$Config valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Bitmap$Config?>(const $Bitmap$Config$NullableType$());
  }
}

final class $Bitmap$Config$NullableType$ extends jni$_.JType<Bitmap$Config?> {
  @jni$_.internal
  const $Bitmap$Config$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Bitmap$Config.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Bitmap$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$NullableType$) &&
        other is $Bitmap$Config$NullableType$;
  }
}

final class $Bitmap$Config$Type$ extends jni$_.JType<Bitmap$Config> {
  @jni$_.internal
  const $Bitmap$Config$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config fromReference(jni$_.JReference reference) =>
      Bitmap$Config.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Bitmap$Config?> get nullableType =>
      const $Bitmap$Config$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$Type$) &&
        other is $Bitmap$Config$Type$;
  }
}

/// from: `android.graphics.Bitmap`
class Bitmap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Bitmap> $type;

  @jni$_.internal
  Bitmap.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Bitmap?> nullableType = $Bitmap$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Bitmap> type = $Bitmap$Type$();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.graphics.Bitmap> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.$JObject$NullableType$());

  /// from: `static public final int DENSITY_NONE`
  static const DENSITY_NONE = 0;
  static final _id_asShared = _class.instanceMethodId(
    r'asShared',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _asShared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Bitmap asShared()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? asShared() {
    return _asShared(
      reference.pointer,
      _id_asShared as jni$_.JMethodIDPtr,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_compress = _class.instanceMethodId(
    r'compress',
    r'(Landroid/graphics/Bitmap$CompressFormat;ILjava/io/OutputStream;)Z',
  );

  static final _compress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean compress(android.graphics.Bitmap$CompressFormat compressFormat, int i, java.io.OutputStream outputStream)`
  bool compress(
    Bitmap$CompressFormat? compressFormat,
    int i,
    jni$_.JObject? outputStream,
  ) {
    final _$compressFormat = compressFormat?.reference ?? jni$_.jNullReference;
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _compress(
      reference.pointer,
      _id_compress as jni$_.JMethodIDPtr,
      _$compressFormat.pointer,
      i,
      _$outputStream.pointer,
    ).boolean;
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Landroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public android.graphics.Bitmap copy(android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? copy(Bitmap$Config? config, bool z) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$config.pointer,
      z ? 1 : 0,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_copyPixelsFromBuffer = _class.instanceMethodId(
    r'copyPixelsFromBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsFromBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void copyPixelsFromBuffer(java.nio.Buffer buffer)`
  void copyPixelsFromBuffer(jni$_.JBuffer? buffer) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsFromBuffer(
      reference.pointer,
      _id_copyPixelsFromBuffer as jni$_.JMethodIDPtr,
      _$buffer.pointer,
    ).check();
  }

  static final _id_copyPixelsToBuffer = _class.instanceMethodId(
    r'copyPixelsToBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsToBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void copyPixelsToBuffer(java.nio.Buffer buffer)`
  void copyPixelsToBuffer(jni$_.JBuffer? buffer) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsToBuffer(
      reference.pointer,
      _id_copyPixelsToBuffer as jni$_.JMethodIDPtr,
      _$buffer.pointer,
    ).check();
  }

  static final _id_createBitmap = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap(Bitmap? bitmap) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap(
      _class.reference.pointer,
      _id_createBitmap as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$1 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIII)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$1(Bitmap? bitmap, int i, int i1, int i2, int i3) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap$1(
      _class.reference.pointer,
      _id_createBitmap$1 as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
      i,
      i1,
      i2,
      i3,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$2 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$2(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni$_.JObject? matrix,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    final _$matrix = matrix?.reference ?? jni$_.jNullReference;
    return _createBitmap$2(
      _class.reference.pointer,
      _id_createBitmap$2 as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
      i,
      i1,
      i2,
      i3,
      _$matrix.pointer,
      z ? 1 : 0,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$3 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$3(jni$_.JObject? picture) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    return _createBitmap$3(
      _class.reference.pointer,
      _id_createBitmap$3 as jni$_.JMethodIDPtr,
      _$picture.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$4 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$4(
    jni$_.JObject? picture,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$4(
      _class.reference.pointer,
      _id_createBitmap$4 as jni$_.JMethodIDPtr,
      _$picture.pointer,
      i,
      i1,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$5 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$5(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$5(
      _class.reference.pointer,
      _id_createBitmap$5 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
      i,
      i1,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$6 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$6(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$6(
      _class.reference.pointer,
      _id_createBitmap$6 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
      i,
      i1,
      _$config.pointer,
      z ? 1 : 0,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$7 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$7(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$7(
      _class.reference.pointer,
      _id_createBitmap$7 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
      i,
      i1,
      _$config.pointer,
      z ? 1 : 0,
      _$colorSpace.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$8 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$8(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$8(
      _class.reference.pointer,
      _id_createBitmap$8 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
      _$is$.pointer,
      i,
      i1,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$9 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$9(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$9(
      _class.reference.pointer,
      _id_createBitmap$9 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
      _$is$.pointer,
      i,
      i1,
      i2,
      i3,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$10 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$10(int i, int i1, Bitmap$Config? config) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$10(
      _class.reference.pointer,
      _id_createBitmap$10 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$11 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$11(int i, int i1, Bitmap$Config? config, bool z) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$11(
      _class.reference.pointer,
      _id_createBitmap$11 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$config.pointer,
      z ? 1 : 0,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$12 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$12(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$12(
      _class.reference.pointer,
      _id_createBitmap$12 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$config.pointer,
      z ? 1 : 0,
      _$colorSpace.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$13 = _class.staticMethodId(
    r'createBitmap',
    r'([IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$13(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$13(
      _class.reference.pointer,
      _id_createBitmap$13 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
      i1,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createBitmap$14 = _class.staticMethodId(
    r'createBitmap',
    r'([IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$14(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$14(
      _class.reference.pointer,
      _id_createBitmap$14 as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
      i1,
      i2,
      i3,
      _$config.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_createScaledBitmap = _class.staticMethodId(
    r'createScaledBitmap',
    r'(Landroid/graphics/Bitmap;IIZ)Landroid/graphics/Bitmap;',
  );

  static final _createScaledBitmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap bitmap, int i, int i1, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createScaledBitmap(Bitmap? bitmap, int i, int i1, bool z) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createScaledBitmap(
      _class.reference.pointer,
      _id_createScaledBitmap as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
      i,
      i1,
      z ? 1 : 0,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
      reference.pointer,
      _id_describeContents as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_eraseColor = _class.instanceMethodId(r'eraseColor', r'(I)V');

  static final _eraseColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void eraseColor(int i)`
  void eraseColor(int i) {
    _eraseColor(
      reference.pointer,
      _id_eraseColor as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_eraseColor$1 = _class.instanceMethodId(
    r'eraseColor',
    r'(J)V',
  );

  static final _eraseColor$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void eraseColor(long j)`
  void eraseColor$1(int j) {
    _eraseColor$1(
      reference.pointer,
      _id_eraseColor$1 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_extractAlpha = _class.instanceMethodId(
    r'extractAlpha',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Bitmap extractAlpha()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha() {
    return _extractAlpha(
      reference.pointer,
      _id_extractAlpha as jni$_.JMethodIDPtr,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_extractAlpha$1 = _class.instanceMethodId(
    r'extractAlpha',
    r'(Landroid/graphics/Paint;[I)Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha$1(jni$_.JObject? paint, jni$_.JIntArray? is$) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _extractAlpha$1(
      reference.pointer,
      _id_extractAlpha$1 as jni$_.JMethodIDPtr,
      _$paint.pointer,
      _$is$.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_getAllocationByteCount = _class.instanceMethodId(
    r'getAllocationByteCount',
    r'()I',
  );

  static final _getAllocationByteCount =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getAllocationByteCount()`
  int getAllocationByteCount() {
    return _getAllocationByteCount(
      reference.pointer,
      _id_getAllocationByteCount as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getByteCount = _class.instanceMethodId(
    r'getByteCount',
    r'()I',
  );

  static final _getByteCount =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getByteCount()`
  int getByteCount() {
    return _getByteCount(
      reference.pointer,
      _id_getByteCount as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getColor = _class.instanceMethodId(
    r'getColor',
    r'(II)Landroid/graphics/Color;',
  );

  static final _getColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public android.graphics.Color getColor(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColor(int i, int i1) {
    return _getColor(
      reference.pointer,
      _id_getColor as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getColorSpace = _class.instanceMethodId(
    r'getColorSpace',
    r'()Landroid/graphics/ColorSpace;',
  );

  static final _getColorSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.ColorSpace getColorSpace()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorSpace() {
    return _getColorSpace(
      reference.pointer,
      _id_getColorSpace as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getConfig = _class.instanceMethodId(
    r'getConfig',
    r'()Landroid/graphics/Bitmap$Config;',
  );

  static final _getConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Bitmap$Config getConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap$Config? getConfig() {
    return _getConfig(
      reference.pointer,
      _id_getConfig as jni$_.JMethodIDPtr,
    ).object<Bitmap$Config?>(const $Bitmap$Config$NullableType$());
  }

  static final _id_getDensity = _class.instanceMethodId(r'getDensity', r'()I');

  static final _getDensity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDensity()`
  int getDensity() {
    return _getDensity(
      reference.pointer,
      _id_getDensity as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getGainmap = _class.instanceMethodId(
    r'getGainmap',
    r'()Landroid/graphics/Gainmap;',
  );

  static final _getGainmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Gainmap getGainmap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getGainmap() {
    return _getGainmap(
      reference.pointer,
      _id_getGainmap as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getGenerationId = _class.instanceMethodId(
    r'getGenerationId',
    r'()I',
  );

  static final _getGenerationId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getGenerationId()`
  int getGenerationId() {
    return _getGenerationId(
      reference.pointer,
      _id_getGenerationId as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getHardwareBuffer = _class.instanceMethodId(
    r'getHardwareBuffer',
    r'()Landroid/hardware/HardwareBuffer;',
  );

  static final _getHardwareBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.hardware.HardwareBuffer getHardwareBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getHardwareBuffer() {
    return _getHardwareBuffer(
      reference.pointer,
      _id_getHardwareBuffer as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getHeight = _class.instanceMethodId(r'getHeight', r'()I');

  static final _getHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHeight()`
  int getHeight() {
    return _getHeight(
      reference.pointer,
      _id_getHeight as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getNinePatchChunk = _class.instanceMethodId(
    r'getNinePatchChunk',
    r'()[B',
  );

  static final _getNinePatchChunk =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getNinePatchChunk()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getNinePatchChunk() {
    return _getNinePatchChunk(
      reference.pointer,
      _id_getNinePatchChunk as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_getPixel = _class.instanceMethodId(r'getPixel', r'(II)I');

  static final _getPixel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public int getPixel(int i, int i1)`
  int getPixel(int i, int i1) {
    return _getPixel(
      reference.pointer,
      _id_getPixel as jni$_.JMethodIDPtr,
      i,
      i1,
    ).integer;
  }

  static final _id_getPixels = _class.instanceMethodId(
    r'getPixels',
    r'([IIIIIII)V',
  );

  static final _getPixels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public void getPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void getPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _getPixels(
      reference.pointer,
      _id_getPixels as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
    ).check();
  }

  static final _id_getRowBytes = _class.instanceMethodId(
    r'getRowBytes',
    r'()I',
  );

  static final _getRowBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getRowBytes()`
  int getRowBytes() {
    return _getRowBytes(
      reference.pointer,
      _id_getRowBytes as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getScaledHeight = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getScaledHeight(android.graphics.Canvas canvas)`
  int getScaledHeight(jni$_.JObject? canvas) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledHeight(
      reference.pointer,
      _id_getScaledHeight as jni$_.JMethodIDPtr,
      _$canvas.pointer,
    ).integer;
  }

  static final _id_getScaledHeight$1 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledHeight$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getScaledHeight(android.util.DisplayMetrics displayMetrics)`
  int getScaledHeight$1(jni$_.JObject? displayMetrics) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledHeight$1(
      reference.pointer,
      _id_getScaledHeight$1 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
    ).integer;
  }

  static final _id_getScaledHeight$2 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(I)I',
  );

  static final _getScaledHeight$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getScaledHeight(int i)`
  int getScaledHeight$2(int i) {
    return _getScaledHeight$2(
      reference.pointer,
      _id_getScaledHeight$2 as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_getScaledWidth = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getScaledWidth(android.graphics.Canvas canvas)`
  int getScaledWidth(jni$_.JObject? canvas) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledWidth(
      reference.pointer,
      _id_getScaledWidth as jni$_.JMethodIDPtr,
      _$canvas.pointer,
    ).integer;
  }

  static final _id_getScaledWidth$1 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledWidth$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getScaledWidth(android.util.DisplayMetrics displayMetrics)`
  int getScaledWidth$1(jni$_.JObject? displayMetrics) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledWidth$1(
      reference.pointer,
      _id_getScaledWidth$1 as jni$_.JMethodIDPtr,
      _$displayMetrics.pointer,
    ).integer;
  }

  static final _id_getScaledWidth$2 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(I)I',
  );

  static final _getScaledWidth$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getScaledWidth(int i)`
  int getScaledWidth$2(int i) {
    return _getScaledWidth$2(
      reference.pointer,
      _id_getScaledWidth$2 as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_getWidth = _class.instanceMethodId(r'getWidth', r'()I');

  static final _getWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getWidth()`
  int getWidth() {
    return _getWidth(
      reference.pointer,
      _id_getWidth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_hasAlpha = _class.instanceMethodId(r'hasAlpha', r'()Z');

  static final _hasAlpha =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasAlpha()`
  bool hasAlpha() {
    return _hasAlpha(
      reference.pointer,
      _id_hasAlpha as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_hasGainmap = _class.instanceMethodId(r'hasGainmap', r'()Z');

  static final _hasGainmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasGainmap()`
  bool hasGainmap() {
    return _hasGainmap(
      reference.pointer,
      _id_hasGainmap as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_hasMipMap = _class.instanceMethodId(r'hasMipMap', r'()Z');

  static final _hasMipMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasMipMap()`
  bool hasMipMap() {
    return _hasMipMap(
      reference.pointer,
      _id_hasMipMap as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isMutable = _class.instanceMethodId(r'isMutable', r'()Z');

  static final _isMutable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMutable()`
  bool isMutable() {
    return _isMutable(
      reference.pointer,
      _id_isMutable as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isPremultiplied = _class.instanceMethodId(
    r'isPremultiplied',
    r'()Z',
  );

  static final _isPremultiplied =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPremultiplied()`
  bool isPremultiplied() {
    return _isPremultiplied(
      reference.pointer,
      _id_isPremultiplied as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isRecycled = _class.instanceMethodId(r'isRecycled', r'()Z');

  static final _isRecycled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isRecycled()`
  bool isRecycled() {
    return _isRecycled(
      reference.pointer,
      _id_isRecycled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_prepareToDraw = _class.instanceMethodId(
    r'prepareToDraw',
    r'()V',
  );

  static final _prepareToDraw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void prepareToDraw()`
  void prepareToDraw() {
    _prepareToDraw(
      reference.pointer,
      _id_prepareToDraw as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_reconfigure = _class.instanceMethodId(
    r'reconfigure',
    r'(IILandroid/graphics/Bitmap$Config;)V',
  );

  static final _reconfigure =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void reconfigure(int i, int i1, android.graphics.Bitmap$Config config)`
  void reconfigure(int i, int i1, Bitmap$Config? config) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _reconfigure(
      reference.pointer,
      _id_reconfigure as jni$_.JMethodIDPtr,
      i,
      i1,
      _$config.pointer,
    ).check();
  }

  static final _id_recycle = _class.instanceMethodId(r'recycle', r'()V');

  static final _recycle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void recycle()`
  void recycle() {
    _recycle(reference.pointer, _id_recycle as jni$_.JMethodIDPtr).check();
  }

  static final _id_sameAs = _class.instanceMethodId(
    r'sameAs',
    r'(Landroid/graphics/Bitmap;)Z',
  );

  static final _sameAs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean sameAs(android.graphics.Bitmap bitmap)`
  bool sameAs(Bitmap? bitmap) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _sameAs(
      reference.pointer,
      _id_sameAs as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
    ).boolean;
  }

  static final _id_setColorSpace = _class.instanceMethodId(
    r'setColorSpace',
    r'(Landroid/graphics/ColorSpace;)V',
  );

  static final _setColorSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setColorSpace(android.graphics.ColorSpace colorSpace)`
  void setColorSpace(jni$_.JObject? colorSpace) {
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    _setColorSpace(
      reference.pointer,
      _id_setColorSpace as jni$_.JMethodIDPtr,
      _$colorSpace.pointer,
    ).check();
  }

  static final _id_setConfig = _class.instanceMethodId(
    r'setConfig',
    r'(Landroid/graphics/Bitmap$Config;)V',
  );

  static final _setConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setConfig(android.graphics.Bitmap$Config config)`
  void setConfig(Bitmap$Config? config) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _setConfig(
      reference.pointer,
      _id_setConfig as jni$_.JMethodIDPtr,
      _$config.pointer,
    ).check();
  }

  static final _id_setDensity = _class.instanceMethodId(r'setDensity', r'(I)V');

  static final _setDensity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDensity(int i)`
  void setDensity(int i) {
    _setDensity(
      reference.pointer,
      _id_setDensity as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setGainmap = _class.instanceMethodId(
    r'setGainmap',
    r'(Landroid/graphics/Gainmap;)V',
  );

  static final _setGainmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setGainmap(android.graphics.Gainmap gainmap)`
  void setGainmap(jni$_.JObject? gainmap) {
    final _$gainmap = gainmap?.reference ?? jni$_.jNullReference;
    _setGainmap(
      reference.pointer,
      _id_setGainmap as jni$_.JMethodIDPtr,
      _$gainmap.pointer,
    ).check();
  }

  static final _id_setHasAlpha = _class.instanceMethodId(
    r'setHasAlpha',
    r'(Z)V',
  );

  static final _setHasAlpha =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setHasAlpha(boolean z)`
  void setHasAlpha(bool z) {
    _setHasAlpha(
      reference.pointer,
      _id_setHasAlpha as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setHasMipMap = _class.instanceMethodId(
    r'setHasMipMap',
    r'(Z)V',
  );

  static final _setHasMipMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setHasMipMap(boolean z)`
  void setHasMipMap(bool z) {
    _setHasMipMap(
      reference.pointer,
      _id_setHasMipMap as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setHeight = _class.instanceMethodId(r'setHeight', r'(I)V');

  static final _setHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setHeight(int i)`
  void setHeight(int i) {
    _setHeight(
      reference.pointer,
      _id_setHeight as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setPixel = _class.instanceMethodId(r'setPixel', r'(III)V');

  static final _setPixel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setPixel(int i, int i1, int i2)`
  void setPixel(int i, int i1, int i2) {
    _setPixel(
      reference.pointer,
      _id_setPixel as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).check();
  }

  static final _id_setPixels = _class.instanceMethodId(
    r'setPixels',
    r'([IIIIIII)V',
  );

  static final _setPixels =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void setPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _setPixels(
      reference.pointer,
      _id_setPixels as jni$_.JMethodIDPtr,
      _$is$.pointer,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
    ).check();
  }

  static final _id_setPremultiplied = _class.instanceMethodId(
    r'setPremultiplied',
    r'(Z)V',
  );

  static final _setPremultiplied =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPremultiplied(boolean z)`
  void setPremultiplied(bool z) {
    _setPremultiplied(
      reference.pointer,
      _id_setPremultiplied as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setWidth = _class.instanceMethodId(r'setWidth', r'(I)V');

  static final _setWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setWidth(int i)`
  void setWidth(int i) {
    _setWidth(reference.pointer, _id_setWidth as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_wrapHardwareBuffer = _class.staticMethodId(
    r'wrapHardwareBuffer',
    r'(Landroid/hardware/HardwareBuffer;Landroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _wrapHardwareBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Bitmap wrapHardwareBuffer(android.hardware.HardwareBuffer hardwareBuffer, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? wrapHardwareBuffer(
    jni$_.JObject? hardwareBuffer,
    jni$_.JObject? colorSpace,
  ) {
    final _$hardwareBuffer = hardwareBuffer?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _wrapHardwareBuffer(
      _class.reference.pointer,
      _id_wrapHardwareBuffer as jni$_.JMethodIDPtr,
      _$hardwareBuffer.pointer,
      _$colorSpace.pointer,
    ).object<Bitmap?>(const $Bitmap$NullableType$());
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(jni$_.JObject? parcel, int i) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(
      reference.pointer,
      _id_writeToParcel as jni$_.JMethodIDPtr,
      _$parcel.pointer,
      i,
    ).check();
  }
}

final class $Bitmap$NullableType$ extends jni$_.JType<Bitmap?> {
  @jni$_.internal
  const $Bitmap$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Bitmap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Bitmap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$NullableType$) &&
        other is $Bitmap$NullableType$;
  }
}

final class $Bitmap$Type$ extends jni$_.JType<Bitmap> {
  @jni$_.internal
  const $Bitmap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap fromReference(jni$_.JReference reference) =>
      Bitmap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Bitmap?> get nullableType => const $Bitmap$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Type$) && other is $Bitmap$Type$;
  }
}
